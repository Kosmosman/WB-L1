### 1. Какой самый эффективный способ конкатенации строк?
Лучше всего, согласно бенчмаркам, показал себя метод strings.Join

Тесты:
```go
package tests

import (
	"fmt"
	"math/rand"
	"strings"
	"testing"
)

var (
	str = []string{
		GenerateLongString(),
		GenerateLongString(),
		GenerateLongString(),
	}
)

func GenerateLongString() string {
	b := make([]byte, 1000000)
	for i := 0; i < 1000000; i++ {
		b[i] = byte(rand.Intn(80) + '!')
	}
	return string(b)
}

func BenchmarkConcatWithJoin(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = strings.Join(str, "")
	}
}

func BenchmarkConcatWithSprintf(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = fmt.Sprintf("%s%s%s", str[0], str[1], str[2])
	}
}

func BenchmarkConcatWithPlus(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = str[0] + str[1] + str[2]
	}
}

func BenchmarkConcatWithBuilder(b *testing.B) {
	for i := 0; i < b.N; i++ {
		builder := strings.Builder{}
		builder.WriteString(str[0])
		builder.WriteString(str[1])
		builder.WriteString(str[2])
		_ = builder.String()
	}
}

func BenchmarkConcatInByteView(b *testing.B) {
	byteString := make([]byte, 3000001)
	for i := 0; i < b.N; i++ {
		pos := 0
		for _, s := range str {
			pos += copy(byteString[pos:], s)
		}
		_ = string(byteString[:])
	}
}
```
Результаты:
```
/tmp/GoLand/___gobench_WB_L1_Questions_bech.test -test.v -test.paniconexit0 -test.bench . -test.run ^$
goos: linux
goarch: amd64
pkg: WB-L1/Questions/bech
cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz
BenchmarkConcatWithJoin
BenchmarkConcatWithJoin-16       	    7737	    151372 ns/op
BenchmarkConcatWithSprintf
BenchmarkConcatWithSprintf-16    	    1104	   1375307 ns/op
BenchmarkConcatWithPlus
BenchmarkConcatWithPlus-16       	    6594	    187880 ns/op
BenchmarkConcatWithBuilder
BenchmarkConcatWithBuilder-16    	    2636	    430146 ns/op
BenchmarkConcatInByteView
BenchmarkConcatInByteView-16     	    3681	    329147 ns/op
PASS
```

### 2. Что такое интерфейсы, как они применяются в Go?

Интерфейсы представляют собой набор методов, определенных без их реализации. 
Они позволяют определить, какие методы должны быть реализованы в определенном типе данных, независимо от конкретной реализации этого типа. 
В Go интерфейсы используются для достижения полиморфизма, что позволяет обрабатывать различные типы данных с помощью общих методов.

Для создания интерфейса в Go используется ключевое слово "type", за которым следует имя интерфейса и список методов, которые должны быть реализованы. Пример:

```go
type SomeInterface interface {
    SomeMethod() int
    AnotherSomeMethod()
}
```

Затем любой тип данных, который реализует все методы интерфейса, автоматически удовлетворяет этому интерфейсу. 
Это позволяет писать более гибкий и модульный код в Go.

### 3. Чем отличаются RWMutex от Mutex?

Mutex - примитив синхронизации, позволяющий в конкурентной среде иметь уникальный доступ к ресурсу для одной горутины, заставляя ожидать её освобождения для остальных горутин.

RWMutex - более гибкий мьютекс, он позволяет нескольким горутинам читать данные одновременно, но блокирует доступ для записи, 
если другая горутина уже выполняет запись или чтение с блокировкой.

### 4. Чем отличаются буферизированные и не буферизированные каналы?

Буфферизированные каналы имеет очередь элементов, который определяется на этапе его создания вторым аргументом. 
Операция отправления в буфферизированный канал вставляет отправляемый элемент в конец очереди, а операция получения удаляет первый элемент из очереди.
Если очередь заполнена, то канал получения своей горутины будет заблокирован, пока другая горутина не освободит место, получив данные из канала. И
наоборот, если канал пуст, операция получения заблокирует горутину до тех пор, пока из другой горутины не будет получено значение в канал.

Небуфферизированные каналы ведут себя также, как буфферизированные, но не имею буффера для заполнения, 
и блокирую горутину до получения значения из того же канала из другой горутины или ожидают отправления значения в тот же канал.

### 5. Какой размер у структуры struct{}{}?
Структура struct{}{} имеет нулевой размер.

### 6. Есть ли в Go перегрузка методов или операторов?
Нет, в Go нет такого элемента статического полиморфизма, как перегрузки методов или операторов.

### 7. В какой последовательности будут выведены элементы map[int]int?
```go
Пример:
m[0]=1
m[1]=124
m[2]=281
```
Не определено, поскольку отображение в Go основано на использовании хэш-таблицы, 
в которой не гарантируется порядок элементов для эффективного доступа к ним

### 8. В чем разница make и new?
Оператор make используется для создания объектов слайсов, отображений и каналов 
и инициализирует их соответствующим образом с передаваемыми параметрами. 

Оператор new создает неименнованную переменную, инициализирует её нулевым значением и возвращает её адрес.

Таким образом, основное различие между make и new заключается в их назначении: 
new используется для выделения памяти и возвращает указатель, в то время как make используется для инициализации слайсов, отображений и каналов 
и возвращает инициализированный объект.

### 9. Сколько существует способов задать переменную типа slice или map?
Существует 4 способа:
```go
    /* Slise */
    sl1 := []any{"something", "in", "the", "way"}    // Краткая инициализация
    var sl2 = []any{"something", "in", "the", "way"} // Инициализация с использованием объявления var
    sl3 := make([]any, 10, 20)                       // Создание с помощью функции make
    sl4 := sl1                                       // Создание через присванивание другого слайса
    
    /* Map */
    m1 := map[int]int{1: 1, 2: 3, 4: 6}    // Инициализация с использованием литерала отображения
    var m2 = map[int]int{1: 1, 2: 3, 4: 6} // Инициализация с использованием объявления var
    m3 := make(map[int]int)                // Создание с помощью функции make
    m4 := m1                               // Создание через присваивание другого отображения
```

### 10. Что выведет данная программа и почему?

```go
func update(p *int) {
    b := 2
    p = &b
}

func main() {
    var (
        a = 1
        p = &a
    )
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}
```
Вывод: 
```go
1
1
```
Так происходит, потому что в функцию update поступает копия указателя p, и все изменения, коснувшиеся его в методе, 
ни коим образом не затрагивают основную программу.

Вот измененный код, в котором мы передаем указатель на указатель p, и изменение адреса, на который указывает p, сохраняется:
```go
func update(p **int) {
	b := 2
	*p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(&p)
	fmt.Println(*p)
}
```
Вывод:
```go
1
2
```
### 11. Что выведет данная программа и почему?

```go
func main() {
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
    wg.Add(1)
    go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
    }(wg, i)
}
wg.Wait()
fmt.Println("exit")
}
```
Вывод:
```go
0
1
2
3
4
// Или любой другой порядок чисел
fatal error: all goroutines are asleep - deadlock!

```
Поскольку в анонимные горутиные функции передавалась копия объекта wg, то изменения счетчика затрагивали только локальные копии, 
вследствие чего программа блокируется из-за wg.Wait(), ожидающей уменьшения счетчика до 0.

Вот исправленная версия программы, в который wg передается в горутину по ссылке:
```go
func main() {
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
    wg.Add(1)
    go func(wg *sync.WaitGroup, i int) {
    defer wg.Done()
    fmt.Println(i)
    }(&wg, i)
}
wg.Wait()
fmt.Println("exit")
}
```

### 12. Что выведет данная программа и почему?

```go
func main() {
n := 0
if true {
n := 1
n++
}
fmt.Println(n)
}
```
Вывод:
```go
0
```
В блоке if создается новая переменная n, которая перекрывает область видимости внешней аналогичной переменной, 
и изменения внутренней n не влияют на внешнюю.

### 13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}
    
func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
Вывод:
```go
[100 2 3 4 5]
```
В метод SomeAction передается копия слайса, которая позволяет изменять элементы, содержащиеся в нем, однако слайс имеет тип:
```go
type Slice struct {
    pointer *int
	len, cap int
}
```
что означает, что длина и объем не изменяются, поскольку передаются копии их значений, 
а элементы в памяти, на которые указывает указатель, подвержены изменениям.

Измененная версия кода:
```go
func someAction(v *[]int8, b int8) {
    (*v)[0] = 100
    *v = append(*v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(&a, 6)
    fmt.Println(a)
}
```
Вывод:
```go
[100 2 3 4 5 6]
```
### 14. Что выведет данная программа и почему?

```go
func main() {
    slice := []string{"a", "a"}
    
    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
        }(slice)
    fmt.Print(slice)
}
```
Вывод:
```go
[b b a][a a]
```
Поскольку в анонимную функцию мы передаем копию слайса, то все изменения затронут только элементы, на которые указывает внутренняя ссылка.
Однако в данном случае происходит изменение слайса путем присваивания его новому вследствие использования append, поэтому первоначальный 
указатель затирается и переприсваивается на новый выделенный участок памяти
